From f19fcae5c16684ed2c9bd0bb800f68a51fa934fa Mon Sep 17 00:00:00 2001
From: Brian Ference <brianference@protonmail.com>
Date: Tue, 27 Jan 2026 21:13:08 +0000
Subject: [PATCH] Add client-side transcript fetching with rate limiting and
 fallback

- Add transcriptFetcher.ts utility for browser-based YouTube transcript fetching
- Implement rate limiting (2s between requests, max 20/min) with exponential backoff
- Add backend proxy endpoints for CORS bypass (/api/proxy/youtube-page, /api/proxy/youtube-transcript)
- Add /api/videos/:id/transcript/store endpoint to save client-fetched transcripts
- Update Videos.tsx to try client-side fetch first, fallback to server-side
- Add 5-minute response caching to reduce YouTube requests
- Support optional residential proxy via RESIDENTIAL_PROXY_URL env var

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
---
 client/src/lib/transcriptFetcher.ts | 336 ++++++++++++++++++++++++++++
 client/src/pages/Videos.tsx         |  49 +++-
 server/routes.ts                    | 253 +++++++++++++++++++++
 3 files changed, 632 insertions(+), 6 deletions(-)
 create mode 100644 client/src/lib/transcriptFetcher.ts

diff --git a/client/src/lib/transcriptFetcher.ts b/client/src/lib/transcriptFetcher.ts
new file mode 100644
index 0000000..27d15e6
--- /dev/null
+++ b/client/src/lib/transcriptFetcher.ts
@@ -0,0 +1,336 @@
+/**
+ * Client-side YouTube Transcript Fetcher
+ * Fetches transcripts directly from the user's browser (bypassing cloud IP blocks)
+ *
+ * Includes rate limiting and retry logic to prevent throttling
+ */
+
+interface TranscriptSnippet {
+  text: string;
+  start: number;
+  duration: number;
+}
+
+interface TranscriptResult {
+  videoId: string;
+  language: string;
+  languageCode: string;
+  isGenerated: boolean;
+  snippets: TranscriptSnippet[];
+  fullText: string;
+}
+
+interface CaptionTrack {
+  baseUrl: string;
+  name: { simpleText: string };
+  languageCode: string;
+  isTranslatable: boolean;
+  kind?: string; // 'asr' for auto-generated
+}
+
+// Rate limiting configuration
+const RATE_LIMIT = {
+  minDelayBetweenRequests: 2000, // 2 seconds minimum between requests
+  maxRetries: 3,
+  baseRetryDelay: 3000, // 3 seconds base delay for retries
+  maxRetryDelay: 30000, // 30 seconds max delay
+};
+
+// Track last request time for rate limiting
+let lastRequestTime = 0;
+const requestQueue: Array<() => void> = [];
+let isProcessingQueue = false;
+
+/**
+ * Wait for rate limit before making request
+ */
+async function waitForRateLimit(): Promise<void> {
+  const now = Date.now();
+  const timeSinceLastRequest = now - lastRequestTime;
+
+  if (timeSinceLastRequest < RATE_LIMIT.minDelayBetweenRequests) {
+    const waitTime = RATE_LIMIT.minDelayBetweenRequests - timeSinceLastRequest;
+    console.log(`[TranscriptFetcher] Rate limiting: waiting ${waitTime}ms`);
+    await sleep(waitTime);
+  }
+
+  lastRequestTime = Date.now();
+}
+
+/**
+ * Sleep helper
+ */
+function sleep(ms: number): Promise<void> {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
+/**
+ * Exponential backoff delay calculation
+ */
+function getRetryDelay(attempt: number): number {
+  const delay = RATE_LIMIT.baseRetryDelay * Math.pow(2, attempt);
+  // Add jitter (Â±20%) to prevent thundering herd
+  const jitter = delay * 0.2 * (Math.random() - 0.5);
+  return Math.min(delay + jitter, RATE_LIMIT.maxRetryDelay);
+}
+
+/**
+ * Fetch with retry logic
+ */
+async function fetchWithRetry(url: string, options?: RequestInit): Promise<Response> {
+  let lastError: Error | null = null;
+
+  for (let attempt = 0; attempt < RATE_LIMIT.maxRetries; attempt++) {
+    try {
+      await waitForRateLimit();
+
+      const response = await fetch(url, options);
+
+      // Check for rate limiting response
+      if (response.status === 429) {
+        const retryAfter = response.headers.get('Retry-After');
+        const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : getRetryDelay(attempt);
+        console.warn(`[TranscriptFetcher] Rate limited (429). Waiting ${waitTime}ms before retry ${attempt + 1}/${RATE_LIMIT.maxRetries}`);
+        await sleep(waitTime);
+        continue;
+      }
+
+      // Check for server errors that might be temporary
+      if (response.status >= 500) {
+        const waitTime = getRetryDelay(attempt);
+        console.warn(`[TranscriptFetcher] Server error (${response.status}). Waiting ${waitTime}ms before retry ${attempt + 1}/${RATE_LIMIT.maxRetries}`);
+        await sleep(waitTime);
+        continue;
+      }
+
+      return response;
+
+    } catch (error: any) {
+      lastError = error;
+
+      // Network errors - retry with backoff
+      if (error.name === 'TypeError' || error.message.includes('network')) {
+        const waitTime = getRetryDelay(attempt);
+        console.warn(`[TranscriptFetcher] Network error. Waiting ${waitTime}ms before retry ${attempt + 1}/${RATE_LIMIT.maxRetries}`);
+        await sleep(waitTime);
+        continue;
+      }
+
+      // Other errors - don't retry
+      throw error;
+    }
+  }
+
+  throw lastError || new Error('Max retries exceeded');
+}
+
+/**
+ * Extract video ID from various YouTube URL formats
+ */
+export function extractVideoId(urlOrId: string): string | null {
+  // If it's already just an ID (11 characters)
+  if (/^[a-zA-Z0-9_-]{11}$/.test(urlOrId)) {
+    return urlOrId;
+  }
+
+  // Try to parse as URL
+  try {
+    const url = new URL(urlOrId);
+
+    // youtube.com/watch?v=VIDEO_ID
+    if (url.hostname.includes('youtube.com')) {
+      return url.searchParams.get('v');
+    }
+
+    // youtu.be/VIDEO_ID
+    if (url.hostname === 'youtu.be') {
+      return url.pathname.slice(1);
+    }
+  } catch {
+    // Not a valid URL
+  }
+
+  return null;
+}
+
+/**
+ * Fetch transcript directly from YouTube
+ * This works from the browser because it uses the user's IP (not blocked like cloud IPs)
+ */
+export async function fetchTranscriptClientSide(videoId: string, preferredLanguages: string[] = ['en']): Promise<TranscriptResult> {
+  console.log(`[TranscriptFetcher] Starting fetch for video: ${videoId}`);
+
+  try {
+    // Step 1: Fetch the YouTube video page to get caption data
+    // We use our backend proxy since YouTube doesn't allow direct CORS requests
+    console.log(`[TranscriptFetcher] Fetching video page metadata...`);
+    const response = await fetchWithRetry(`/api/proxy/youtube-page?videoId=${videoId}`);
+
+    if (!response.ok) {
+      const errorText = await response.text();
+      throw new Error(`Failed to fetch video page: ${response.status} - ${errorText}`);
+    }
+
+    const html = await response.text();
+
+    // Step 2: Extract caption tracks from the page
+    const captionTracks = extractCaptionTracks(html);
+
+    if (!captionTracks || captionTracks.length === 0) {
+      throw new Error('No captions available for this video. The video may not have subtitles enabled.');
+    }
+
+    console.log(`[TranscriptFetcher] Found ${captionTracks.length} caption track(s)`);
+
+    // Step 3: Find the best caption track (prefer manual over auto-generated)
+    const selectedTrack = selectBestCaptionTrack(captionTracks, preferredLanguages);
+
+    if (!selectedTrack) {
+      throw new Error(`No captions found for languages: ${preferredLanguages.join(', ')}`);
+    }
+
+    console.log(`[TranscriptFetcher] Selected track: ${selectedTrack.languageCode} (${selectedTrack.kind === 'asr' ? 'auto-generated' : 'manual'})`);
+
+    // Step 4: Fetch the actual transcript XML
+    // Add small delay between page fetch and transcript fetch
+    await sleep(500);
+
+    console.log(`[TranscriptFetcher] Fetching transcript content...`);
+    const transcriptResponse = await fetchWithRetry(`/api/proxy/youtube-transcript?url=${encodeURIComponent(selectedTrack.baseUrl)}`);
+
+    if (!transcriptResponse.ok) {
+      throw new Error('Failed to fetch transcript content');
+    }
+
+    const transcriptXml = await transcriptResponse.text();
+
+    // Step 5: Parse the transcript XML
+    const snippets = parseTranscriptXml(transcriptXml);
+
+    if (snippets.length === 0) {
+      throw new Error('Transcript was empty or could not be parsed');
+    }
+
+    // Step 6: Build the full text
+    const fullText = snippets.map(s => s.text).join(' ');
+
+    console.log(`[TranscriptFetcher] Successfully fetched transcript: ${snippets.length} snippets, ${fullText.length} characters`);
+
+    return {
+      videoId,
+      language: selectedTrack.name?.simpleText || selectedTrack.languageCode,
+      languageCode: selectedTrack.languageCode,
+      isGenerated: selectedTrack.kind === 'asr',
+      snippets,
+      fullText,
+    };
+
+  } catch (error: any) {
+    console.error('[TranscriptFetcher] Fetch failed:', error);
+    throw new Error(error.message || 'Failed to fetch transcript');
+  }
+}
+
+/**
+ * Extract caption track information from YouTube page HTML
+ */
+function extractCaptionTracks(html: string): CaptionTrack[] {
+  try {
+    // Look for the captions data in the page
+    const captionsRegex = /"captions":\s*(\{[\s\S]*?"captionTracks":\s*\[[\s\S]*?\][\s\S]*?\})/;
+    const match = html.match(captionsRegex);
+
+    if (!match) {
+      // Try alternative pattern
+      const altRegex = /captionTracks":\s*(\[[\s\S]*?\])/;
+      const altMatch = html.match(altRegex);
+
+      if (altMatch) {
+        try {
+          return JSON.parse(altMatch[1]);
+        } catch {
+          return [];
+        }
+      }
+      return [];
+    }
+
+    try {
+      const captionsData = JSON.parse(match[1]);
+      return captionsData.playerCaptionsTracklistRenderer?.captionTracks || [];
+    } catch {
+      return [];
+    }
+  } catch {
+    return [];
+  }
+}
+
+/**
+ * Select the best caption track based on language preference
+ */
+function selectBestCaptionTrack(tracks: CaptionTrack[], preferredLanguages: string[]): CaptionTrack | null {
+  // First, try to find a manual caption in preferred languages
+  for (const lang of preferredLanguages) {
+    const manualTrack = tracks.find(
+      t => t.languageCode.startsWith(lang) && t.kind !== 'asr'
+    );
+    if (manualTrack) return manualTrack;
+  }
+
+  // Fall back to auto-generated in preferred languages
+  for (const lang of preferredLanguages) {
+    const autoTrack = tracks.find(
+      t => t.languageCode.startsWith(lang) && t.kind === 'asr'
+    );
+    if (autoTrack) return autoTrack;
+  }
+
+  // Fall back to any manual caption
+  const anyManual = tracks.find(t => t.kind !== 'asr');
+  if (anyManual) return anyManual;
+
+  // Fall back to any caption
+  return tracks[0] || null;
+}
+
+/**
+ * Parse YouTube's transcript XML format
+ */
+function parseTranscriptXml(xml: string): TranscriptSnippet[] {
+  const snippets: TranscriptSnippet[] = [];
+
+  // Parse XML using DOMParser (browser-native)
+  const parser = new DOMParser();
+  const doc = parser.parseFromString(xml, 'text/xml');
+
+  const textElements = doc.querySelectorAll('text');
+
+  textElements.forEach(element => {
+    const start = parseFloat(element.getAttribute('start') || '0');
+    const duration = parseFloat(element.getAttribute('dur') || '0');
+    const text = decodeHtmlEntities(element.textContent || '');
+
+    if (text.trim()) {
+      snippets.push({ text: text.trim(), start, duration });
+    }
+  });
+
+  return snippets;
+}
+
+/**
+ * Decode HTML entities in transcript text
+ */
+function decodeHtmlEntities(text: string): string {
+  const textarea = document.createElement('textarea');
+  textarea.innerHTML = text;
+  return textarea.value
+    .replace(/&#39;/g, "'")
+    .replace(/&quot;/g, '"')
+    .replace(/&amp;/g, '&')
+    .replace(/&lt;/g, '<')
+    .replace(/&gt;/g, '>')
+    .replace(/\n/g, ' ')
+    .trim();
+}
diff --git a/client/src/pages/Videos.tsx b/client/src/pages/Videos.tsx
index 36d858b..0483cfa 100644
--- a/client/src/pages/Videos.tsx
+++ b/client/src/pages/Videos.tsx
@@ -11,6 +11,7 @@ import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 import { Search, Download, Sparkles, Filter, X } from "lucide-react";
 import { useToast } from "@/hooks/use-toast";
 import { apiRequest, queryClient } from "@/lib/queryClient";
+import { fetchTranscriptClientSide } from "@/lib/transcriptFetcher";
 import type { Video, Channel } from "@shared/schema";
 
 export default function Videos() {
@@ -83,9 +84,45 @@ export default function Videos() {
   });
 
   const downloadTranscriptMutation = useMutation({
-    mutationFn: async (videoId: string) => {
-      const response = await apiRequest('POST', `/api/videos/${videoId}/transcript`, undefined);
-      return await response.json();
+    mutationFn: async (videoDbId: string) => {
+      // Find the video to get its YouTube videoId
+      const video = videos.find(v => v.id === videoDbId);
+      if (!video) {
+        throw new Error('Video not found');
+      }
+
+      console.log(`[TranscriptDownload] Starting client-side fetch for: ${video.videoId}`);
+
+      try {
+        // Step 1: Fetch transcript using client-side method (uses user's IP via proxy)
+        const transcriptData = await fetchTranscriptClientSide(video.videoId, ['en', 'en-US', 'en-GB']);
+
+        console.log(`[TranscriptDownload] Client-side fetch successful, storing transcript...`);
+
+        // Step 2: Store the transcript on the server
+        const storeResponse = await apiRequest('POST', `/api/videos/${videoDbId}/transcript/store`, transcriptData);
+
+        if (!storeResponse.ok) {
+          const errorData = await storeResponse.json();
+          throw new Error(errorData.error || 'Failed to store transcript');
+        }
+
+        return await storeResponse.json();
+
+      } catch (clientError: any) {
+        console.warn(`[TranscriptDownload] Client-side fetch failed: ${clientError.message}`);
+        console.log(`[TranscriptDownload] Falling back to server-side fetch...`);
+
+        // Fallback: Try server-side fetching (may work if server has different IP/proxy)
+        const response = await apiRequest('POST', `/api/videos/${videoDbId}/transcript`, undefined);
+
+        if (!response.ok) {
+          const errorData = await response.json();
+          throw new Error(errorData.error || 'Failed to download transcript');
+        }
+
+        return await response.json();
+      }
     },
     onMutate: (videoId: string) => {
       setDownloadingVideoId(videoId);
@@ -95,14 +132,14 @@ export default function Videos() {
       queryClient.invalidateQueries({ queryKey: ['/api/videos'] });
       toast({
         title: "Transcript downloaded",
-        description: `Transcript available in ${data.transcript.language}`,
+        description: `Transcript available in ${data.transcript?.language || 'English'}`,
       });
     },
     onError: (error: any) => {
       setDownloadingVideoId(null);
       toast({
-        title: "Error",
-        description: error.message || "Failed to download transcript",
+        title: "Error downloading transcript",
+        description: error.message || "Failed to download transcript. YouTube may be blocking requests.",
         variant: "destructive",
       });
     },
diff --git a/server/routes.ts b/server/routes.ts
index dce9bc1..25c0d45 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -5,6 +5,72 @@ import { spawn } from "child_process";
 import { insertChannelSchema, insertVideoSchema, insertTranscriptSchema, insertInsightSchema } from "@shared/schema";
 import { z } from "zod";
 import { fromZodError } from "zod-validation-error";
+import { HttpsProxyAgent } from "https-proxy-agent";
+
+// Optional residential proxy support via environment variable
+// Format: http://user:pass@proxy.example.com:port
+const RESIDENTIAL_PROXY = process.env.RESIDENTIAL_PROXY_URL;
+
+// Rate limiting for proxy requests
+const proxyRateLimiter = {
+  lastRequestTime: 0,
+  minDelay: 1500, // 1.5 seconds between requests
+  requestCount: 0,
+  resetTime: Date.now(),
+  maxRequestsPerMinute: 20,
+};
+
+async function waitForProxyRateLimit(): Promise<void> {
+  const now = Date.now();
+
+  // Reset counter every minute
+  if (now - proxyRateLimiter.resetTime > 60000) {
+    proxyRateLimiter.requestCount = 0;
+    proxyRateLimiter.resetTime = now;
+  }
+
+  // Check if we've exceeded rate limit
+  if (proxyRateLimiter.requestCount >= proxyRateLimiter.maxRequestsPerMinute) {
+    const waitTime = 60000 - (now - proxyRateLimiter.resetTime);
+    console.log(`[ProxyRateLimit] Max requests reached, waiting ${waitTime}ms`);
+    await new Promise(resolve => setTimeout(resolve, waitTime));
+    proxyRateLimiter.requestCount = 0;
+    proxyRateLimiter.resetTime = Date.now();
+  }
+
+  // Enforce minimum delay between requests
+  const timeSinceLastRequest = now - proxyRateLimiter.lastRequestTime;
+  if (timeSinceLastRequest < proxyRateLimiter.minDelay) {
+    const waitTime = proxyRateLimiter.minDelay - timeSinceLastRequest;
+    await new Promise(resolve => setTimeout(resolve, waitTime));
+  }
+
+  proxyRateLimiter.lastRequestTime = Date.now();
+  proxyRateLimiter.requestCount++;
+}
+
+// Simple in-memory cache for YouTube responses (5 minute TTL)
+const proxyCache = new Map<string, { data: string; timestamp: number }>();
+const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
+
+function getCachedResponse(key: string): string | null {
+  const cached = proxyCache.get(key);
+  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
+    console.log(`[ProxyCache] Cache hit for ${key.substring(0, 50)}...`);
+    return cached.data;
+  }
+  proxyCache.delete(key);
+  return null;
+}
+
+function setCachedResponse(key: string, data: string): void {
+  // Limit cache size
+  if (proxyCache.size > 100) {
+    const oldestKey = proxyCache.keys().next().value;
+    if (oldestKey) proxyCache.delete(oldestKey);
+  }
+  proxyCache.set(key, { data, timestamp: Date.now() });
+}
 
 // Helper function to run Python scripts
 function runPythonScript(scriptName: string, args: string[]): Promise<{ stdout: string; stderr: string }> {
@@ -709,6 +775,193 @@ ${transcript.fullText}
     }
   });
 
+  // ============================================================================
+  // CLIENT-SIDE TRANSCRIPT FETCHING SUPPORT
+  // These endpoints act as CORS proxies to allow browser-based transcript fetching
+  // ============================================================================
+
+  // GET /api/proxy/youtube-page - Fetch YouTube video page for caption extraction
+  app.get("/api/proxy/youtube-page", async (req, res) => {
+    try {
+      const { videoId } = req.query;
+
+      if (!videoId || typeof videoId !== 'string') {
+        return res.status(400).json({ error: 'videoId query parameter is required' });
+      }
+
+      // Check cache first
+      const cacheKey = `page:${videoId}`;
+      const cached = getCachedResponse(cacheKey);
+      if (cached) {
+        return res.send(cached);
+      }
+
+      // Rate limit
+      await waitForProxyRateLimit();
+
+      const url = `https://www.youtube.com/watch?v=${videoId}`;
+      console.log(`[ProxyYouTube] Fetching video page: ${videoId}`);
+
+      const fetchOptions: RequestInit = {
+        headers: {
+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+          'Accept-Language': 'en-US,en;q=0.9',
+          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
+        },
+      };
+
+      // Use residential proxy if configured
+      if (RESIDENTIAL_PROXY) {
+        console.log(`[ProxyYouTube] Using residential proxy`);
+        const agent = new HttpsProxyAgent(RESIDENTIAL_PROXY);
+        (fetchOptions as any).agent = agent;
+      }
+
+      const response = await fetch(url, fetchOptions);
+
+      if (!response.ok) {
+        console.error(`[ProxyYouTube] YouTube returned ${response.status}`);
+        return res.status(response.status).json({ error: `YouTube returned ${response.status}` });
+      }
+
+      const html = await response.text();
+
+      // Verify we got valid YouTube page (not a block/captcha page)
+      if (html.includes('accounts.google.com/ServiceLogin') || html.includes('consent.youtube.com')) {
+        console.error('[ProxyYouTube] YouTube returned consent/login page - IP may be flagged');
+        return res.status(403).json({ error: 'YouTube requires consent/login - try again later or use residential proxy' });
+      }
+
+      // Cache the response
+      setCachedResponse(cacheKey, html);
+
+      res.send(html);
+    } catch (error: any) {
+      console.error('[ProxyYouTube] Error fetching video page:', error);
+      res.status(500).json({ error: error.message || 'Failed to fetch video page' });
+    }
+  });
+
+  // GET /api/proxy/youtube-transcript - Fetch transcript XML from YouTube
+  app.get("/api/proxy/youtube-transcript", async (req, res) => {
+    try {
+      const { url } = req.query;
+
+      if (!url || typeof url !== 'string') {
+        return res.status(400).json({ error: 'url query parameter is required' });
+      }
+
+      // Validate URL is a YouTube timedtext URL
+      if (!url.includes('youtube.com') && !url.includes('googlevideo.com')) {
+        return res.status(400).json({ error: 'Invalid transcript URL' });
+      }
+
+      // Check cache first
+      const cacheKey = `transcript:${url}`;
+      const cached = getCachedResponse(cacheKey);
+      if (cached) {
+        return res.type('text/xml').send(cached);
+      }
+
+      // Rate limit
+      await waitForProxyRateLimit();
+
+      console.log(`[ProxyYouTube] Fetching transcript from: ${url.substring(0, 80)}...`);
+
+      const fetchOptions: RequestInit = {
+        headers: {
+          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+          'Accept': 'text/xml,application/xml,*/*',
+        },
+      };
+
+      // Use residential proxy if configured
+      if (RESIDENTIAL_PROXY) {
+        const agent = new HttpsProxyAgent(RESIDENTIAL_PROXY);
+        (fetchOptions as any).agent = agent;
+      }
+
+      const response = await fetch(url, fetchOptions);
+
+      if (!response.ok) {
+        console.error(`[ProxyYouTube] Transcript fetch returned ${response.status}`);
+        return res.status(response.status).json({ error: `Failed to fetch transcript: ${response.status}` });
+      }
+
+      const xml = await response.text();
+
+      // Cache the response
+      setCachedResponse(cacheKey, xml);
+
+      res.type('text/xml').send(xml);
+    } catch (error: any) {
+      console.error('[ProxyYouTube] Error fetching transcript:', error);
+      res.status(500).json({ error: error.message || 'Failed to fetch transcript' });
+    }
+  });
+
+  // POST /api/videos/:id/transcript/store - Store a client-fetched transcript
+  app.post("/api/videos/:id/transcript/store", async (req, res) => {
+    try {
+      const video = await storage.getVideo(req.params.id);
+      if (!video) {
+        return res.status(404).json({ error: 'Video not found' });
+      }
+
+      // Validate the transcript data from the client
+      const { videoId, language, languageCode, isGenerated, snippets, fullText } = req.body;
+
+      if (!videoId || !language || !languageCode || !snippets || !fullText) {
+        return res.status(400).json({ error: 'Missing required transcript fields' });
+      }
+
+      // Verify videoId matches
+      if (videoId !== video.videoId) {
+        return res.status(400).json({ error: 'Video ID mismatch' });
+      }
+
+      // Check if transcript already exists
+      const existingTranscript = await storage.getTranscriptByVideoId(video.videoId);
+      if (existingTranscript) {
+        return res.json({ transcript: existingTranscript, message: 'Transcript already exists' });
+      }
+
+      // Validate snippets structure
+      if (!Array.isArray(snippets) || snippets.length === 0) {
+        return res.status(400).json({ error: 'Invalid snippets array' });
+      }
+
+      // Save transcript
+      const validatedTranscript = insertTranscriptSchema.parse({
+        videoId,
+        language,
+        languageCode,
+        isGenerated: isGenerated || false,
+        snippets,
+        fullText,
+      });
+
+      const transcript = await storage.createTranscript(validatedTranscript);
+
+      // Update video
+      await storage.updateVideo(video.id, {
+        hasTranscript: true,
+        transcriptDownloaded: true,
+      });
+
+      console.log(`[TranscriptStore] Stored client-fetched transcript for ${videoId}: ${snippets.length} snippets`);
+
+      res.json({ transcript, message: 'Transcript stored successfully' });
+    } catch (error: any) {
+      console.error('[TranscriptStore] Error storing transcript:', error);
+      if (error instanceof z.ZodError) {
+        const validationError = fromZodError(error);
+        return res.status(400).json({ error: validationError.message });
+      }
+      res.status(500).json({ error: error.message || 'Failed to store transcript' });
+    }
+  });
+
   const httpServer = createServer(app);
   return httpServer;
 }
-- 
2.34.1

